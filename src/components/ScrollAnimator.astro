---
---

<script is:inline>
  (() => {
    const SELECTOR = '[data-animate]';
    let observer;
    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)');
    let motionListenerAdded = false;
    let swapListenerAdded = false;

    const normalizeTime = (value, fallback) => {
      if (!value) return fallback;
      const trimmed = value.trim();
      if (!trimmed) return fallback;
      if (trimmed.endsWith('ms') || trimmed.endsWith('s')) {
        return trimmed;
      }
      const numeric = Number(trimmed);
      if (!Number.isFinite(numeric)) return fallback;
      return numeric >= 10 ? `${numeric}ms` : `${numeric}s`;
    };

    const multiplyTime = (value, factor) => {
      const normalized = normalizeTime(value, '0s');
      if (normalized.endsWith('ms')) {
        const base = parseFloat(normalized.replace('ms', '')) || 0;
        return `${base * factor}ms`;
      }
      const base = parseFloat(normalized.replace('s', '')) || 0;
      return `${base * factor}s`;
    };

    const applyTiming = el => {
      const existingDelay = el.style.getPropertyValue('--animate-delay');
      const delayAttr = el.getAttribute('data-animate-delay');
      const durationAttr = el.getAttribute('data-animate-duration');
      const easingAttr = el.getAttribute('data-animate-easing');

      const delay = normalizeTime(delayAttr ?? existingDelay, existingDelay || '0s');
      const duration = normalizeTime(durationAttr, '0.7s');
      const easing = easingAttr?.trim() || 'cubic-bezier(0.22, 1, 0.36, 1)';

      el.style.setProperty('--animate-delay', delay);
      el.style.setProperty('--animate-duration', duration);
      el.style.setProperty('--animate-easing', easing);
    };

    const applyCustomProperties = el => {
      const distance = el.getAttribute('data-animate-distance');
      const perspective = el.getAttribute('data-animate-perspective');
      const blur = el.getAttribute('data-animate-blur');
      const opacity = el.getAttribute('data-animate-opacity');
      const opacityVisible = el.getAttribute('data-animate-opacity-visible');

      if (distance) el.style.setProperty('--animate-distance', distance);
      if (perspective) el.style.setProperty('--animate-perspective', perspective);
      if (blur) el.style.setProperty('--animate-filter', `blur(${blur})`);
      if (opacity) el.style.setProperty('--animate-opacity', opacity);
      if (opacityVisible) el.style.setProperty('--animate-opacity-visible', opacityVisible);
    };

    const applyStagger = group => {
      const step = group.getAttribute('data-animate-stagger') ?? '0.08s';
      const children = group.querySelectorAll(':scope > [data-animate]');
      children.forEach((child, index) => {
        if (!child.hasAttribute('data-animate-delay') && !child.style.getPropertyValue('--animate-delay')) {
          child.style.setProperty('--animate-delay', multiplyTime(step, index));
        }
      });
    };

    const cleanupObserver = () => {
      if (observer) {
        observer.disconnect();
        observer = undefined;
      }
    };

    const revealOnce = entries => {
      entries.forEach(entry => {
        const target = entry.target;
        if (!(target instanceof HTMLElement)) return;
        const shouldRepeat = target.getAttribute('data-animate-repeat') === 'true';

        if (entry.isIntersecting) {
          target.classList.add('is-visible');
          if (!shouldRepeat) {
            observer?.unobserve(target);
          }
        } else if (shouldRepeat) {
          target.classList.remove('is-visible');
        }
      });
    };

    const init = () => {
      cleanupObserver();

      const groups = document.querySelectorAll('[data-animate-stagger]');
      groups.forEach(applyStagger);

      const elements = document.querySelectorAll(SELECTOR);

      elements.forEach(el => {
        applyTiming(el);
        applyCustomProperties(el);
        el.classList.add('anim-ready');
      });

      if (!elements.length) return;

      if (prefersReduced.matches) {
        elements.forEach(el => {
          el.classList.add('is-visible');
        });
        return;
      }

      observer = new IntersectionObserver(revealOnce, {
        threshold: 0.22,
        rootMargin: '0px 0px -12% 0px',
      });

      elements.forEach(el => observer?.observe(el));
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, { once: true });
    } else {
      init();
    }

    if (!motionListenerAdded) {
      prefersReduced.addEventListener('change', () => {
        init();
      });
      motionListenerAdded = true;
    }

    if (!swapListenerAdded) {
      document.addEventListener('astro:after-swap', init);
      swapListenerAdded = true;
    }
  })();
</script>
